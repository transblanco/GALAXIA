<script>
/* index.html UI glue: usa window.APP.* (serverless-based) que debes tener en /GALAXIA/app.js
   - FRONTEND_CONFIG debe existir (en /GALAXIA/frontend-config.js). */

(function(){
  // Safety checks
  if(typeof FRONTEND_CONFIG === 'undefined') {
    alert('Falta frontend-config.js (FRONTEND_CONFIG). Añádelo en /GALAXIA/frontend-config.js');
    throw new Error('FRONTEND_CONFIG missing');
  }

  // Local state
  let admin = false;
  let tasks = [];
  let areas = [];
  let respons = [];
  let currentIndex = null;

  // Helpers
  function escapeHtml(s){ if(!s && s !== 0) return ''; return String(s).replaceAll('&','&amp;').replaceAll('<','&lt;').replaceAll('>','&gt;').replaceAll('"','&quot;').replaceAll("'",'&#039;'); }
  function formatPct(v){ if(v===null||v===undefined||v==='') return '—'; return `${v}%`; }
  function compareItems(a,b){ if(!a) return 1; if(!b) return -1; const pa=(a+'').split('.').map(x=>parseInt(x)||0); const pb=(b+'').split('.').map(x=>parseInt(x)||0); for(let i=0;i<Math.max(pa.length,pb.length);i++){ if((pa[i]||0) < (pb[i]||0)) return -1; if((pa[i]||0) > (pb[i]||0)) return 1; } return 0; }
  function getAreaColorByName(name){ const f = areas.find(x=>x.nombre === name); return f ? f.color : '#6b7280'; }

  // Wait for window.APP to exist (timeout fallback)
  async function waitForApp(timeout = 5000){
    if(window.APP) return;
    return new Promise((resolve) => {
      const start = Date.now();
      const id = setInterval(()=> {
        if(window.APP) { clearInterval(id); resolve(); }
        if(Date.now() - start > timeout){ clearInterval(id); resolve(); }
      }, 150);
    });
  }
  
  /* ⚡ OPTIMIZED SAVE FUNCTION ⚡ */
  // Centraliza la lógica de guardado de tareas y actualiza localmente
  async function saveTasksAndRefreshUI(newTaskArray = tasks, refreshTable = true, refreshDetail = false){
    tasks = newTaskArray; // Actualiza la variable global con la versión más reciente
    try {
      if(window.APP && (typeof window.APP.saveTareas === 'function' || typeof window.APP.saveTasks === 'function')){
        const saveFunc = window.APP.saveTareas || window.APP.saveTasks;
        await saveFunc(tasks);
      } else {
        // Sin función de guardado, solo persiste localmente (no es un problema aquí, pero es buen feedback)
        console.warn("No hay función de guardado (window.APP.saveTareas/saveTasks). Solo cambios locales.");
      }
      if (refreshTable) renderTable();
      if (refreshDetail && currentIndex !== null) openDetail(currentIndex, false); // Re-renderiza el detalle SIN recargar datos
      return true;
    } catch(err){
      console.error('Error guardando tarea', err);
      alert('Error guardando tarea: ' + (err.message||err));
      return false;
    }
  }


  // Load data via window.APP
  async function loadAll(){
    await waitForApp();
    let fetchedData = {};
    
    if(window.APP && typeof window.APP.loadAll === 'function'){
      try { fetchedData = await window.APP.loadAll() || {}; } catch(e){ console.warn('Error window.APP.loadAll', e); fetchedData = {}; }
    }

    // Fallback or merge with raw files
    if(Object.keys(fetchedData).length === 0){
      const rawBase = FRONTEND_CONFIG.RAW_BASE || '';
      try {
        const rT = await fetch(rawBase + (FRONTEND_CONFIG.FILES.tareas || 'tareas.json'));
        fetchedData.tareas = rT.ok ? await rT.json() : [];
      } catch(e){ fetchedData.tareas = []; }
      try {
        const rA = await fetch(rawBase + (FRONTEND_CONFIG.FILES.areas || 'areas.json'));
        fetchedData.areas = rA.ok ? await rA.json() : [];
      } catch(e){ fetchedData.areas = []; }
      try {
        const rR = await fetch(rawBase + (FRONTEND_CONFIG.FILES.responsables || 'responsables.json'));
        fetchedData.respons = rR.ok ? await rR.json() : [];
      } catch(e){ fetchedData.respons = []; }
    }

    // normalize arrays if necessary
    tasks = fetchedData.tareas && Array.isArray(fetchedData.tareas) ? fetchedData.tareas : (fetchedData.tareas && fetchedData.tareas.tareas) || [];
    areas = fetchedData.areas && Array.isArray(fetchedData.areas) ? fetchedData.areas : (fetchedData.areas && fetchedData.areas.areas) || [];
    respons = fetchedData.respons && Array.isArray(fetchedData.respons) ? fetchedData.respons : (fetchedData.respons && fetchedData.respons.responsables) || [];


    renderAreasAndResps();
    renderTable();
  }

  /* 🧠 CORE LOGIC: Nivel / Avance 🧠 */
  // Calcula el avance y asegura la coherencia de niveles cumplidos
  function calculateTaskProgress(task){
    // 1. Encontrar el nivel más alto cumplido.
    let highestCompletedLevelValue = 0;
    (task.niveles || []).forEach(n => {
      if (n.cumplido && Number.isFinite(n.valor) && n.valor > highestCompletedLevelValue) {
        highestCompletedLevelValue = n.valor;
      }
    });

    // 2. Si el avance manual (admin) es mayor al nivel más alto cumplido, respeta el avance manual.
    if (task.avance > highestCompletedLevelValue) {
      // 3. Ajustar los niveles cumplidos para que coincidan con el avance manual (si es mayor)
      (task.niveles || []).forEach(n => {
        // Si el avance es mayor o igual al valor del nivel, se considera cumplido
        if (task.avance >= n.valor) {
          n.cumplido = true;
        }
      });
      return task.avance; // Devuelve el avance manual
    }

    // 4. Si el avance manual es menor o igual al nivel más alto, se usa el valor del nivel cumplido.
    task.avance = highestCompletedLevelValue;
    return highestCompletedLevelValue;
  }
  
  /* ---------- Render UI ---------- */
  function renderAreasAndResps(){
    const selA = document.getElementById('selectAreas'); if(selA){ selA.innerHTML = ''; areas.forEach(a=>{ const opt = document.createElement('option'); opt.value = a.nombre; opt.textContent = a.nombre; selA.appendChild(opt); }); }
    const selR = document.getElementById('selectResp'); if(selR){ selR.innerHTML = ''; respons.forEach(r=>{ const opt = document.createElement('option'); opt.value = r; opt.textContent = r; selR.appendChild(opt); }); }
    document.getElementById('countAreas').innerText = areas.length || 0;
  }

  function renderTable(){
    // Recalcula el avance antes de renderizar la tabla para mantener la coherencia
    const arr = [...tasks].map(t => { t.avance = calculateTaskProgress(t); return t; }).sort((x,y)=>compareItems(x.item,y.item));
    
    document.getElementById('countTasks').innerText = arr.length || 0;
    if(arr.length === 0){
      document.getElementById('taskTable').innerHTML = `<div class="p-8 text-center small-muted">No hay tareas. ${ admin ? 'Crea una con ➕ Nueva tarea' : 'Pide a un administrador crear una tarea.' }</div>`;
      return;
    }
    let html = `<table class="w-full text-left"><thead>
      <tr class="text-zinc-400 text-sm">
        <th class="p-3">Item</th>
        <th class="p-3">Título</th>
        <th class="p-3">Áreas</th>
        <th class="p-3">Responsable</th>
        <th class="p-3">Niveles</th>
        <th class="p-3">Carpeta</th>
      </tr></thead><tbody class="space-y-2">`;
    arr.forEach(t => {
      const idx = tasks.findIndex(x => x.id === t.id); // Usamos ID para ser más robustos
      const areasHtml = (t.areas||[]).map(a => `<span class="tag" style="background:${getAreaColorByName(a)}">${escapeHtml(a)}</span>`).join(' ');
      const levelsHtml = (t.niveles||[]).map(n => {
        const c = n.cumplido ? '✅' : '⬜';
        return `<span class="level-badge">${c} N${n.nivel}: ${formatPct(n.valor)}</span>`;
      }).join(' ');
      html += `<tr class="row-hover" onclick="openDetail(${idx})">
        <td class="p-3 align-top"><div class="font-semibold">${escapeHtml(t.item)}</div></td>
        <td class="p-3 align-top"><div class="font-medium">${escapeHtml(t.titulo)}</div></td>
        <td class="p-3 align-top">${areasHtml}</td>
        <td class="p-3 align-top">${escapeHtml(t.responsable)}</td>
        <td class="p-3 align-top">${levelsHtml}</td>
        <td class="p-3 align-top"><a class="text-indigo-400 hover:underline" href="${escapeHtml(t.carpetaDrive||'#')}" target="_blank">📂 Abrir</a></td>
      </tr>`;
    });
    html += `</tbody></table>`;
    document.getElementById('taskTable').innerHTML = html;
  }

  /* ---------- Create modal logic (niveles empiezan en 0) ---------- */
  function openCreateModal(){
    if(!admin){ alert('Solo admin puede crear tareas. Inicia sesión con el código.'); return; }
    document.getElementById('createTitle').innerText = '➕ Nueva tarea';
    document.getElementById('createForm').reset();
    renderAreasAndResps();
    renderNivelInputs();
    document.getElementById('createModal').classList.remove('hidden');
  }
  function closeCreateModal(){ document.getElementById('createModal').classList.add('hidden'); }

  function renderNivelInputs(){
    const cnt = document.getElementById('nivelesInputs'); cnt.innerHTML = '';
    const how = parseInt(document.getElementById('inputCantidadNiv').value) || 1;
    // now levels go from 0 to how-1
    for(let i=0;i<how;i++){
      const wrap = document.createElement('div'); wrap.className='flex gap-2 items-center';
      const label = document.createElement('label'); label.textContent = `Nivel ${i}:`; label.className='small-muted w-24';
      const input = document.createElement('input'); input.type='number'; input.min=0; input.max=100; input.value=0; input.id=`meta_nivel_${i}`;
      input.className='p-2 rounded bg-transparent border border-zinc-700 w-32';
      const pct = document.createElement('span'); pct.className='small-muted'; pct.innerText = '%';
      input.addEventListener('input', ()=> {
        let v = parseInt(input.value) || 0; if(v<0) v=0; if(v>100) v=100; input.value = v;
      });
      wrap.appendChild(label); wrap.appendChild(input); wrap.appendChild(pct);
      cnt.appendChild(wrap);
    }
  }

  // create form submit
  document.getElementById('createForm').addEventListener('submit', async function(e){
    e.preventDefault();
    if(!admin){ alert('Solo admin puede crear tareas.'); return; }

    const item = document.getElementById('inputItem').value.trim();
    const titulo = document.getElementById('inputTitulo').value.trim();
    const seleccion = Array.from(document.getElementById('selectAreas').selectedOptions).map(o=>o.value);
    const responsable = document.getElementById('selectResp').value;
    const cantidad = parseInt(document.getElementById('inputCantidadNiv').value) || 1;
    const metas = [];
    // levels start at 0
    for(let i=0;i<cantidad;i++){
      const el = document.getElementById(`meta_nivel_${i}`);
      const val = parseInt((el || {value:0}).value) || 0;
      metas.push({ nivel: i, valor: val, cumplido: false });
    }
    let avance = parseInt(document.getElementById('inputAvance').value) || 0;
    const carpetaDrive = document.getElementById('inputDrive').value.trim();
    const imagenKpi = document.getElementById('inputImagen').value.trim();

    if(!item || !titulo){ alert('Item y Título obligatorios'); return; }

    const newTask = {
      id: Date.now(), // Usar un ID robusto
      item,
      titulo,
      areas: seleccion.length ? seleccion : ['Sin Área'],
      responsable: responsable || 'Sin responsable',
      niveles: metas,
      avance,
      carpetaDrive,
      imagenKpi,
      comentarios: []
    };
    
    // Calcula el avance inicial de la nueva tarea (ajusta niveles si es necesario)
    calculateTaskProgress(newTask);

    tasks.push(newTask);
    
    if (await saveTasksAndRefreshUI(tasks, true)) {
      closeCreateModal();
      alert('Tarea guardada ✅');
    }
  });

  /* ---------- Detail modal ---------- */
  // El parámetro skipRefreshData permite re-renderizar el modal sin hacer loadAll, evitando lentitud
  function openDetail(idx, skipRefreshData = true){
    currentIndex = idx;
    const t = tasks[idx];
    if(!t) return;
    
    // ⚡ Optimización: Recalcula y actualiza el avance localmente antes de mostrar el detalle
    t.avance = calculateTaskProgress(t);
    
    document.getElementById('detailTitle').innerText = t.titulo;
    document.getElementById('detailItem').innerText = `Item: ${t.item}`;
    const areasWrap = document.getElementById('detailAreas'); areasWrap.innerHTML = '';
    (t.areas||[]).forEach(a=>{
      const s = document.createElement('span'); s.className='tag'; s.style.background = getAreaColorByName(a); s.innerText = a;
      areasWrap.appendChild(s);
    });

    document.getElementById('detailResp').innerText = t.responsable || '—';
    const nivelesUL = document.getElementById('detailNiveles'); nivelesUL.innerHTML = '';
    (t.niveles||[]).forEach((n,i)=>{
      const li = document.createElement('li'); li.className='flex items-center gap-3 py-1';
      const chk = document.createElement('input'); chk.type='checkbox'; chk.checked = !!n.cumplido; chk.disabled = !admin;
      
      // ⚡ Fix: Guardado de Nivel y lógica de Avance
      chk.addEventListener('change', async ()=>{
        if(!admin){ chk.checked = !chk.checked; alert('Solo admin puede cambiar niveles'); return; }
        
        n.cumplido = chk.checked; // ✅ El estado se guarda en el objeto t

        // Recalcula el avance basado en el nuevo estado de niveles
        t.avance = calculateTaskProgress(t);

        if(await saveTasksAndRefreshUI(tasks, true, true)) { // Guarda y re-renderiza tabla y modal
          // updateDetailProgress(t) es llamado por openDetail(..., true)
        } else {
          // Si falla, revierte el estado
          n.cumplido = !chk.checked;
          chk.checked = !chk.checked;
        }
      });
      
      const label = document.createElement('span'); label.innerHTML = `<strong>Nivel ${n.nivel}</strong> — ${formatPct(n.valor)}`;
      li.appendChild(chk); li.appendChild(label); nivelesUL.appendChild(li);
    });

    updateDetailProgress(t);
    document.getElementById('avanceEditWrap').style.display = admin ? 'block' : 'none';
    document.getElementById('avanceEdit').value = t.avance || 0;
    document.getElementById('detailDrive').href = t.carpetaDrive || '#';
    document.getElementById('detailDrive').innerText = t.carpetaDrive ? 'Abrir carpeta' : '—';

    renderComments(t);

    const img = document.getElementById('detailImagen');
    img.src = t.imagenKpi ? t.imagenKpi : 'https://via.placeholder.com/800x400.png?text=Sin+imagen';
    img.alt = 'Imagen KPI';

    document.getElementById('editSaveBtn').style.display = admin ? 'inline-block' : 'none';
    document.getElementById('detailModal').classList.remove('hidden');

    document.getElementById('editSaveBtn').onclick = async function(){
      if(!admin){ alert('Solo admin puede guardar cambios'); return; }
      
      const newAv = parseInt(document.getElementById('avanceEdit').value) || 0;
      t.avance = Math.min(100, Math.max(0, newAv));
      
      // Al editar el avance, llamamos a la lógica de coherencia
      calculateTaskProgress(t);
      
      if(await saveTasksAndRefreshUI(tasks, true, true)) {
        alert('Cambios guardados ✅');
      }
    };
  }

  function closeDetailModal(){ currentIndex = null; document.getElementById('detailModal').classList.add('hidden'); }
  function updateDetailProgress(t){ 
    const bar = document.getElementById('detailProgressBar'); 
    const display = document.getElementById('avanceDisplay'); 
    const value = t.avance || 0; 
    bar.style.width = value + '%'; 
    display.innerText = value + '%'; 
    
    // ⚡ Actualiza los checkboxes en el modal para reflejar el avance calculado
    (t.niveles||[]).forEach((n,i) => {
      const chk = document.querySelector(`#detailNiveles input[type="checkbox"]:nth-child(${i+1})`);
      if(chk) chk.checked = !!n.cumplido;
    });
  }

  /* ---------- Comments ---------- */
  function renderComments(t){
    const ul = document.getElementById('detailComentarios'); ul.innerHTML = '';
    (t.comentarios||[]).slice().reverse().forEach(c=>{
      const li = document.createElement('li'); li.className='mb-2 p-2 bg-zinc-800 rounded';
      const ts = new Date(c.ts || Date.now()).toLocaleString();
      li.innerHTML = `<div class="small-muted text-xs">${escapeHtml(ts)}</div><div class="mt-1">${escapeHtml(c.text)}</div>`;
      ul.appendChild(li);
    });
  }

  async function addComment(){
    const txt = document.getElementById('comentarioText').value.trim();
    if(!txt) return;
    if(currentIndex === null) return;
    const t = tasks[currentIndex];
    t.comentarios = t.comentarios || [];
    t.comentarios.push({ text: txt, ts: Date.now() });
    
    if (await saveTasksAndRefreshUI(tasks, false, false)) { // No recarga tabla ni modal, solo guarda
      document.getElementById('comentarioText').value = '';
      renderComments(t); // Solo re-renderiza la sección de comentarios
    }
  }

  /* ---------- Add Area / Responsable ---------- */
  let addMode = '';
  function openAddModal(mode){
    if(!admin){ alert('Solo admin puede crear áreas/responsables.'); return; }
    addMode = mode;
    document.getElementById('addTitle').innerText = mode === 'area' ? '➕ Nueva Área' : '➕ Nuevo Responsable';
    document.getElementById('addInput').value = '';
    document.getElementById('addColor').value = '';
    document.getElementById('addModal').classList.remove('hidden');
  }
  function closeAddModal(){ document.getElementById('addModal').classList.add('hidden'); }

  function isHexColor(s){ return /^#([0-9A-F]{3}){1,2}$/i.test(s); }
  async function saveAdd(){
    const value = (document.getElementById('addInput').value || '').trim();
    const pick = (document.getElementById('addColor').value || '').trim();
    if(!value) return alert('Ingrese nombre válido');
    
    let success = false;
    
    if(addMode === 'area'){
      const color = isHexColor(pick) ? pick : (function(){ const p = ['#06b6d4','#7c3aed','#ef4444','#f97316','#14b8a6','#0ea5e9','#a3e635','#f43f5e']; return p[Math.floor(Math.random()*p.length)]; })();
      if(!areas.find(x=>x.nombre===value)) areas.push({ nombre: value, color });
      try {
        if(window.APP && typeof window.APP.saveAreas === 'function') await window.APP.saveAreas(areas);
        renderAreasAndResps(); // Solo re-renderiza la selección
        success = true;
      } catch(e){ console.error('saveAreas', e); alert('Error guardando área'); }
    } else {
      if(!respons.includes(value)) respons.push(value);
      try {
        if(window.APP && typeof window.APP.saveRespons === 'function') await window.APP.saveRespons(respons);
        renderAreasAndResps(); // Solo re-renderiza la selección
        success = true;
      } catch(e){ console.error('saveRespons', e); alert('Error guardando responsable'); }
    }
    
    if (success) {
      closeAddModal(); 
      alert((addMode === 'area' ? 'Área' : 'Responsable') + ' guardado ✅');
    }
  }

  /* ---------- Admin login ---------- */
  document.getElementById('loginBtn').addEventListener('click', () => {
    if(admin && document.getElementById('loginBtn').innerText === 'Cerrar sesión'){
      if(confirm('¿Cerrar sesión de admin?')){
        admin = false;
        document.getElementById('adminBadge').classList.add('hidden');
        document.getElementById('newTaskBtn').classList.add('hidden');
        document.getElementById('statusAdmin').innerText = 'Usuario';
        document.getElementById('loginBtn').innerText = '🔑 Ingresar Admin';
        renderTable();
      }
      return;
    }

    const code = prompt('Ingrese código de administrador:');
    if(code === 'william.oliva'){
      admin = true;
      document.getElementById('adminBadge').classList.remove('hidden');
      document.getElementById('newTaskBtn').classList.remove('hidden');
      document.getElementById('statusAdmin').innerText = 'ADMIN';
      document.getElementById('loginBtn').innerText = 'Cerrar sesión';
      alert('Acceso concedido ✅');
      renderTable();
    } else if(code === null){
      // cancel
    } else {
      alert('Código incorrecto ❌');
    }
  });

  // map newTaskBtn
  document.getElementById('newTaskBtn').addEventListener('click', openCreateModal);

  // Expose global functions used in HTML
  window.openDetail = openDetail;
  window.openAddModal = openAddModal;
  window.openCreateModal = openCreateModal;
  window.closeCreateModal = closeCreateModal;
  window.closeAddModal = closeAddModal;
  window.closeDetailModal = closeDetailModal;
  window.saveAdd = saveAdd;
  window.addComment = addComment;
  window.renderNivelInputs = renderNivelInputs; // Exponer por si acaso es necesario en el HTML

  // Boot
  (async function boot(){
    try {
      await loadAll();
      console.log('UI cargada y lista');
    } catch(e){
      console.error('Boot error', e);
      alert('Error inicializando la app: ' + (e && e.message ? e.message : e));
    }
  })();

})();
</script>
